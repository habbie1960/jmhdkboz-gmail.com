
require 'benchmark'
$max_trial = 10

def bm msg
  real = (1..$max_trial).map{
    Benchmark.measure{
      yield
    }.real
  }.min

  puts "#{msg}\t#{real}"
  real
end

def bench1
  max = 10_000_000
  cm = bm 'c-method' do
    max.times{
      null_func()
    }
  end

  ri = bm 'ricsin' do
    max.times{
      __C__('')
    }
  end

  lo = bm 'loop' do
    max.times{
    }
  end

  puts [cm-lo, ri-lo].join("\t")
end

__Cdecl__ %q{
  #define FIX_PP(i) i += 2
  #define FIX_CMP_LT(x, y) ((SIGNED_VALUE)(x) < (SIGNED_VALUE)(y))
}

class Array
  def each_ricsin
    return self.enum_for(:each) unless block_given?
    i = 0
    e = nil
    #C for (; FIX2LONG(i) < RARRAY_LEN(self); FIX_PP(i)) {
    #C   e = RARRAY_PTR(self)[FIX2LONG(i)];
      yield e
    #C }
    self
  end

  def each_ruby
    i = 0
    while i < self.length
      yield self[i]
      i = i.succ
    end
  end
end

class Fixnum
  alias each times
  def each_ricsin
    return self.enum_for(:times) unless block_given?
    i = 0
    #C  for (; FIX_CMP_LT(i, self); FIX_PP(i)) {
          yield i
    #C  }
    i
  end

  def each_ruby
    i = 0
    while i < self
      yield i
      i = i.succ
    end
    i
  end
end

class Range
  def each_ricsin
    return self.enum_for(:each) unless block_given?
    i = self.first
    e = self.last
    e += 1 unless self.exclude_end?

    #C for (; FIX_CMP_LT(i, e); FIX_PP(i)) {
         yield(i)
    #C }

    self
  end

  def each_ruby
    i = self.first
    e = self.last
    e += 1 if self.exclude_end?

    while i<e
      yield
      i = i.succ
    end

    self
  end
end

def bench2
  max = 10_000_000
  [[Array.new(max), :each], [(1..max), :each], [max, :times]].each{|obj, mid|
    begin
      bm 'cfunc' do
        obj.each{}
      end
      bm 'ricsin' do
        obj.each_ricsin{}
      end
      bm 'ruby' do
        obj.each_ruby{}
      end

      bm 'cfunc+cb' do
        obj.each(&__Cb__(''))
      end
      bm 'ricsin+cb' do
        obj.each_ricsin(&__Cb__(''))
      end
      bm 'ruby+cb' do
        obj.each_ruby(&__Cb__(''))
      end
    ensure
      #
    end
  }
end

require 'matrix'

class Matrix
  def *(m) # m is matrix or vector or number
    case(m)
    when Numeric
      rows = @rows.collect {
        |row|
        row.collect {
          |e|
          e * m
        }
      }
      return Matrix.rows(rows, false)
    when Vector
      m = Matrix.column_vector(m)
      r = self * m
      return r.column(0)
    when Matrix
      Matrix.Raise ErrDimensionMismatch if column_size != m.row_size

      if true
        rs = row_size
        cs = column_size
        mary = m.instance_eval{@rows}
        sary = @rows
        rows = __C__ %q{
          int row_size = FIX2INT(rs);
          int column_size = FIX2INT(cs);
          int ci=0, cj=0, ck=0;
          VALUE crows = rb_ary_new();
          for (ci=0; ci<row_size; ci++) {
            VALUE ccols = rb_ary_new();
            for (cj=0; cj<column_size; cj++) {
              int cvij = 0;
	      double d = 0;
              for (ck=0; ck<column_size; ck++) {
                #define REF(m, i, j) RARRAY_PTR(RARRAY_PTR(m)[i])[j]
                VALUE a = REF(sary, ci, ck);
                VALUE b = REF(mary, ck, cj);

                if (FIXNUM_P(a) && FIXNUM_P(b)) {
		    cvij += FIX2INT(a) * FIX2INT(b);
                }
                else if (BUILTIN_TYPE(a) == T_FLOAT &&
			 BUILTIN_TYPE(b) == T_FLOAT) {
		    d += RFLOAT_VALUE(a) * RFLOAT_VALUE(b);
		}
                else {
                  rb_bug("unsupported\n");
                }
              }
	      if (d != 0) {
		  rb_ary_push(ccols, DBL2NUM(d + cvij));
	      }
	      else {
		  rb_ary_push(ccols, INT2NUM(cvij));
	      }
            }
            rb_ary_push(crows, ccols);
          }
          return crows;
        }
      else
        rows = (0 .. row_size - 1).collect {
          |i|
          (0 .. m.column_size - 1).collect {
            |j|
            vij = 0
            0.upto(column_size - 1) do
              |k|
              vij += self[i, k] * m[k, j]
            end
            vij
          }
        }
      end
      return Matrix.rows(rows, false)
    else
      x, y = m.coerce(self)
      return x * y
    end
  end
end

def bench3
  max = 1000
  m1 = Matrix[*Array.new(max){|i|
    Array.new(max){|j|
      i + j
    }
  }]
  bm 'matrix' do
    (m1 * m1)
  end
end

bench3()

__END__

bench1()
bench2()
__END__
###

require 'benchmark'

max = 10000000

obj = Array.new(max)
Benchmark.bm{|x|
  x.report("orig  "){
    obj.each{|e|}
  }
  x.report("ricsin"){
    obj.each2{|e|}
  }
  x.report("pure  "){
    obj.each3{|e|}
  }
} if false

obj = (1..max)
Benchmark.bm{|x|
  x.report("orig  "){
    obj.each{|e|}
  }
  x.report("ricsin"){
    obj.each2{|e|}
  }
  x.report("pure  "){
    obj.each3{|e|}
  }
} if false

Benchmark.bm{|x|
  x.report("orig  "){
    max.times{|i|}
  }
  x.report("ricsin"){
    max.times2{|i|}
  }
  x.report("pure  "){
    max.times3{|i|}
  }
  x.report("cblock"){
    max.times(&__Cb__(""))
  }
  x.report("cblock"){
    max.times2(&__Cb__(""))
  }
  x.report("cblock"){
    max.times3(&__Cb__(""))
  }
}

__END__

ruby 1.9.0 (2008-09-19 revision 0) [i686-linux]

      user     system      total        real
orig    2.860000   0.000000   2.860000 (  2.864203)
ricsin  2.160000   0.000000   2.160000 (  2.161214)
pure    5.130000   0.000000   5.130000 (  5.138235)
      user     system      total        real
orig    2.810000   0.000000   2.810000 (  2.822292)
ricsin  2.070000   0.000000   2.070000 (  2.066880)
pure    2.790000   0.000000   2.790000 (  2.787441)
      user     system      total        real
orig    2.700000   0.000000   2.700000 (  2.697477)
ricsin  2.070000   0.000000   2.070000 (  2.078570)
pure    2.800000   0.000000   2.800000 (  2.794948)


ruby 1.9.0 (2008-09-20 revision 12) [x86_64-linux]

      user     system      total        real
orig    0.830000   0.000000   0.830000 (  0.825043)
ricsin  0.540000   0.010000   0.550000 (  0.545134)
pure    1.310000   0.000000   1.310000 (  1.313828)
      user     system      total        real
orig    0.850000   0.000000   0.850000 (  0.855513)
ricsin  0.560000   0.000000   0.560000 (  0.554663)
pure    0.660000   0.000000   0.660000 (  0.663112)
      user     system      total        real
orig    0.860000   0.000000   0.860000 (  0.854639)
ricsin  0.540000   0.000000   0.540000 (  0.547628)
pure    0.790000   0.000000   0.790000 (  0.787023)





Benchmark.bm{|x|
  x.report("orig  "){
    max.times{|i|}
  }
  x.report("ricsin"){
    max.times2{|i|}
  }
  x.report("pure  "){
    max.times3{|i|}
  }
  x.report("cblock"){
    max.times(&__Cb__(""))
  }
  x.report("cblock"){
    max.times2(&__Cb__(""))
  }
  x.report("cblock"){
    max.times3(&__Cb__(""))
  }
}

      user     system      total        real
orig    2.760000   0.000000   2.760000 (  2.757706)
ricsin  2.230000   0.000000   2.230000 (  2.236137)
pure    3.130000   0.000000   3.130000 (  3.159513)
cblock  1.000000   0.000000   1.000000 (  1.004778)
cblock  1.960000   0.000000   1.960000 (  1.963191)
cblock  2.740000   0.000000   2.740000 (  2.747436)
